# -*- coding: utf-8 -*-
"""AI_Assignment1_AidanKiser.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yLirun4e0MLI9QtLZH13_FHs4ohXX-NU

Aidan Kiser\
COMP-5600\
6 February 2023\
Assigment 1: Search

**Please Note:** <br>
My implementations of BFS and DFS return the list of visited nodes up until the goal node is reached. In some scenarios, they find the goal node before exhausting the entirety of the graph.

**Also Note:** <br>
The report is the bottom text block.

**Parsing the Input files**
"""

import csv

# parse the .txt files
def parse_edge_list(file_path):
    graph = {}
    # open file and read line by line
    with open(file_path, 'r') as file:
        for line in file:
            # split the line into source, target, and weight
            parts = line.strip().split(',')
            source, target, weight = parts[0], parts[1], float(parts[2])
            # add edge to the graph
            if source not in graph:
                graph[source] = []
            if target not in graph:
                graph[target] = []
            graph[source].append((target, weight))
            # also add the reverse edge
            graph[target].append((source, weight))
    return graph

# parse the .csv files
def parse_node_id(file_path):
    node_positions = {}
    # open CSV file using DictReader, reads it into dictionaries
    with open(file_path, newline='') as csvfile:
        reader = csv.DictReader(csvfile, fieldnames=['node', 'x', 'y'])
        for row in reader:
            # store the positions as tuples in a dictionary
            node_positions[row['node']] = (int(row['x']), int(row['y']))
    return node_positions

"""**BFS Implementation**"""

from collections import deque

# this class returns the VISITED nodes in order, not the optimal path (as per the instructions).
def bfs(graph, start, goal):

    # create a queue and enqueue the start node
    queue = deque([start])

    # keep track of visited nodes
    visited_order = []

    # set to keep track of visited nodes to avoid revisiting
    visited = set([start])

    while queue:
        # get the next node from the queue
        current_node = queue.popleft()
        visited_order.append(current_node)

        # stop if the goal node is reached
        if current_node == goal:
          break

        # iterate over all the neighbors
        for neighbor, _ in graph[current_node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return visited_order

"""**DFS Implementation**"""

# this class returns the VISITED nodes in order, not the optimal path (as per the instructions).
def dfs(graph, start, goal):

    # creates the stack
    stack = [start]

    # keep track of visited nodes
    visited_order = []

    # set to keep track of visited nodes to avoid revisiting
    visited = set()

    while stack:
        # pop a node and path from the stack
        current_node = stack.pop()
        # return path if the goal is not reached
        if current_node not in visited:
            visited.add(current_node)
            visited_order.append(current_node)

            # if the goal is found, return the visitation order up to the goal
            if current_node == goal:
                return visited_order

            # get the neighbors and reverse them to keep the correct order for DFS
            neighbors = sorted(graph.get(current_node, []), key=lambda x: x[0], reverse=True)
            for neighbor, _ in neighbors:
                if neighbor not in visited:
                    stack.append(neighbor)

    return visited_order

"""**A* Implementation**"""

import heapq
import math

def manhattan_distance(node_a, node_b):
    # heuristic for Manhattan distance
    (x1, y1) = node_a
    (x2, y2) = node_b
    return abs(x1 - x2) + abs(y1 - y2)

def euclidean_distance(node_a, node_b):
    # heuristic for Euclidean distance
    (x1, y1) = node_a
    (x2, y2) = node_b
    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

def a_star_search(graph, start, goal, heuristic_func, positions):
    # priority queue
    pq = []
    # starting point into the priority queue with f(x) = h(x)
    heapq.heappush(pq, (heuristic_func(positions[start], positions[goal]), start, [start], 0))
    # visited nodes and cost map
    visited = set()
    # loop until the queue is empty
    while pq:
        # pop the element with the smallest cost
        (f, current, path, g) = heapq.heappop(pq)
        # if it's the goal, return the path
        if current == goal:
            return path
        visited.add(current)
        # process each neighbor
        for neighbor, w in graph.get(current, []):
            # calculate the cost from current to neighbor
            if neighbor not in visited:
                # cost from start to neighbor through current
                g_new = g + w
                f_new = g_new + heuristic_func(positions[neighbor], positions[goal])
                # push the neighbor into the queue
                heapq.heappush(pq, (f_new, neighbor, path + [neighbor], g_new))
    return None

"""**BFS on Test Case 1**"""

# define the file paths for Test Case 1
edge_list_file_path = "TestCase_01_EdgeList.txt"
node_id_file_path = "TestCase_01_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_01 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_24'

# run BFS on Test Case 1 from start node to the goal node
bfs_path_testcase_01 = bfs(graph_testcase_01, start_node, goal_node)
print("BFS Path for Test Case 1:", bfs_path_testcase_01)

"""**DFS on Test Case 1**"""

# define the file paths for Test Case 1
edge_list_file_path = "TestCase_01_EdgeList.txt"
node_id_file_path = "TestCase_01_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_01 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_24'

# run BFS on Test Case 1 from start node to the goal node
dfs_path_testcase_01 = dfs(graph_testcase_01, start_node, goal_node)
print("DFS Path for Test Case 1:", dfs_path_testcase_01)

"""**A* on Test Case 1**"""

# define the file paths for Test Case 1
edge_list_file_path = "TestCase_01_EdgeList.txt"
node_id_file_path = "TestCase_01_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_01 = parse_edge_list(edge_list_file_path)
node_positions_testcase_01 = parse_node_id(node_id_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_24'

# the two heuristics
manhattan_heuristic = manhattan_distance
euclidean_heuristic = euclidean_distance

# run A* on Test Case 1 from start node to goal node
a_star_manhattan = a_star_search(graph_testcase_01,
                                 start_node,
                                 goal_node,
                                 manhattan_heuristic,
                                 node_positions_testcase_01)
a_star_euclidean = a_star_search(graph_testcase_01,
                                 start_node,
                                 goal_node,
                                 euclidean_heuristic,
                                 node_positions_testcase_01)

# print
print("A* manhattan Path for Test Case 1:", a_star_manhattan)
print("A* euclidean Path for Test Case 1:", a_star_euclidean)

"""**BFS on Test Case 2**"""

# define the file paths for Test Case 2
edge_list_file_path = "TestCase_02_EdgeList.txt"
node_id_file_path = "TestCase_02_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_02 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_99'

# run BFS on Test Case 2 from start node to the goal node
bfs_path_testcase_02 = bfs(graph_testcase_02, start_node, goal_node)
print("BFS Path for Test Case 2:", bfs_path_testcase_02)

"""**DFS on Test Case 2**"""

# define the file paths for Test Case 2
edge_list_file_path = "TestCase_02_EdgeList.txt"
node_id_file_path = "TestCase_02_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_02 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_99'

# run BFS on Test Case 1 from start node to the goal node
dfs_path_testcase_02 = dfs(graph_testcase_02, start_node, goal_node)
print("DFS Path for Test Case 2:", dfs_path_testcase_02)

"""**A* on Test Case 2**"""

# define the file paths for Test Case 2
edge_list_file_path = "TestCase_02_EdgeList.txt"
node_id_file_path = "TestCase_02_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_02 = parse_edge_list(edge_list_file_path)
node_positions_testcase_02 = parse_node_id(node_id_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_99'

# the two heuristics
manhattan_heuristic = manhattan_distance
euclidean_heuristic = euclidean_distance

# run A* on Test Case 1 from start node to goal node
a_star_manhattan = a_star_search(graph_testcase_02,
                                 start_node,
                                 goal_node,
                                 manhattan_heuristic,
                                 node_positions_testcase_02)
a_star_euclidean = a_star_search(graph_testcase_02,
                                 start_node,
                                 goal_node,
                                 euclidean_heuristic,
                                 node_positions_testcase_02)

# print
print("A* manhattan Path for Test Case 2:", a_star_manhattan)
print("A* euclidean Path for Test Case 2:", a_star_euclidean)

"""**BFS on Test Case 3**"""

# define the file paths for Test Case 3
edge_list_file_path = "TestCase_03_EdgeList.txt"
node_id_file_path = "TestCase_03_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_03 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_999'

# run BFS on Test Case 3 from start node to the goal node
bfs_path_testcase_03 = bfs(graph_testcase_03, start_node, goal_node)
print("BFS Path for Test Case 3:", bfs_path_testcase_03)

"""**DFS on Test Case 3**"""

# define the file paths for Test Case 3
edge_list_file_path = "TestCase_03_EdgeList.txt"
node_id_file_path = "TestCase_03_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_03 = parse_edge_list(edge_list_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_999'

# run BFS on Test Case 1 from start node to the goal node
dfs_path_testcase_03 = dfs(graph_testcase_03, start_node, goal_node)
print("DFS Path for Test Case 3:", dfs_path_testcase_03)

"""**A* on Test Case 3**"""

# define the file paths for Test Case 3
edge_list_file_path = "TestCase_03_EdgeList.txt"
node_id_file_path = "TestCase_03_NodeID.csv"

# parse the testcase files to build the graph structure
graph_testcase_03 = parse_edge_list(edge_list_file_path)
node_positions_testcase_03 = parse_node_id(node_id_file_path)

# set the start and goal nodes
start_node = 'N_0'
goal_node = 'N_999'

# the two heuristics
manhattan_heuristic = manhattan_distance
euclidean_heuristic = euclidean_distance

# run A* on Test Case 1 from start node to goal node
a_star_manhattan = a_star_search(graph_testcase_03,
                                 start_node,
                                 goal_node,
                                 manhattan_heuristic,
                                 node_positions_testcase_03)
a_star_euclidean = a_star_search(graph_testcase_03,
                                 start_node,
                                 goal_node,
                                 euclidean_heuristic,
                                 node_positions_testcase_03)

# print
print("A* manhattan Path for Test Case 3:", a_star_manhattan)
print("A* euclidean Path for Test Case 3:", a_star_euclidean)

"""# ***Report***
**Parse** <br>
I began this project by understanding the input files. To be able to understand, I had to physically write down the graph for Test Case 01 so that I could write the parse class correctly. The edge list is parsed by spliting the three parts of each line and places and adding the edge in a dictionary with the weights to create a graph. As for the nodeID list, the csv file opens using DictReader and appends each row into a dictionary to return the node positions according to their coordinates.
<br>
**BFS Implementation** <br>
Standard BFS implementation using a queue. Only thing to note is that the implementation returns the order of visited nodes up until the target node is found. For the time complexity: by combining the vertex and edge examinations, the overall time complexity of the BFS algorithm becomes O(V+E).
<br>
**DFS Implementation**<br>
Standard DFS implementation using a stack. Only thing to note is that the implementation returns the order of visited nodes up until the target node is found. For the time complexity: logic is very similar, same as BFS: O(V+E).
<br>
**A* Implementation**<br>
I chose both Manhattan and Euclidean heuristics. The Manhttan heuristic admissible when the movement is restricted to orthogonal directions (typically four directions: up, down, left, and right) on a grid. Because each node was defined by its two coordinates, it was clear that it's implementation would be appropriate. Euclidean heuristic is admissible when movement can occur in any direction, including diagonally. The Euclidean distance represents the straight-line distance between two points, which is the shortest possible path between them in a continuous space. In a discrete grid where diagonal movements are allowed and have the same cost as orthogonal movements, Euclidean distance may not always accurately reflect the actual cost due to the non-continuous nature of grid movement. However, it still does not overestimate the actual distance to the goal. As for the search itself, it is very similar to the BFS and DFS searches, but includes the input of the heuristic. As for the time complexity: can theoretically vary between O(bd) and O(b^m) (where b is the number of child nodes for a given node, d is the depth of the shallowest solution, and m is the maximum depth of the search space) depending on the heuristic's effectiveness and the problem's characteristics. With a good heuristic, A can be very efficient; with a bad heuristic, it can degenerate to brute force search.
<br>
**Comparison**<br>
All of the algorithms work for the checked Test Case 01. All of the algorithms are generally quick, where all the checks on each of the Test Cases returned the result in under 1 second.<br>
As for the time complexities:

*   BFS: O(V+E)
*   DFS: O(V+E)
*   A* : between O(bd) and O(b^m)
<br>
<br>
Please see the notes for more details on complexities.
"""